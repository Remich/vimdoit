" File: vimdoit.vim
" Author: René Michalke <rene@renemichalke.de>
" Description: A VIM Project Manager

" Disable loading of plugin.
if exists("g:vimdoit_load") && g:vimdoit_load == 0
  finish
endif

" Save user's options, for restoring at the end of the script.
let s:save_cpo = &cpo
set cpo&vim

" check user option for vim plugin path
if exists("g:vimdoit_plugindir") == v:false
	echoe "Vimdoit: Option 'g:vimdoit_plugindir' not set!"
	finish
endif

" check user option for projects path
if exists("g:vimdoit_projectsdir") == v:false
	echoe "Vimdoit: Option 'g:vimdoit_projectsdir' not set!"
	finish
endif

" check if dateutils are installed
let s:tools = ['dateadd', 'dround']

for t in s:tools
	if trim(system("whereis ".t)) ==# t.":"
		echoe "ERRROR: ".t." not found! A lot of stuff won't work. Please install ".t."."
		finish
	endif
endfor

" check if we are in the project folder
let cwd = getcwd()
if cwd !~# '\v'.g:vimdoit_projectsdir
	finish
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"																Global Variables												   "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:vimdoit_quickfix_type = 'none'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"																Utility Functions													 "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:SetGrep()
	let g:vdo_grep_save = &grepprg
	set grepprg=rg\ --vimgrep
endfunction

function! s:RestoreGrep()
	let &grepprg=g:vdo_grep_save
endfunction

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"																Writing Zettels   												 "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:GetAllProjects(dir)
	let l:cwd = getcwd()
	execute "cd ".a:dir
	
	let l:assoc = { 'name' : a:dir, 'areas' : [], 'projects' : [] }
	let l:files = split(system('ls -1'), '\v\n')
	
	for i in l:files
		if filereadable(i) == v:false
			let l:list = []
			let l:ret = s:GetAllProjects(i)
			call add(l:assoc['areas'], l:ret)
		else
			if match(i, '.*vdo') != -1
				let l:tree = s:ParseProject(i)
				call add(l:assoc['projects'], l:tree)
			endif
		endif
	endfor
	
	execute "cd ".l:cwd
	return l:assoc
endfunction

function! s:ParseProject(name)
	execute "edit! ".a:name
	echom "Parsing: ".a:name
	call s:ParseProjectFile()
	call s:DataComputeProgress()
	let l:tree = deepcopy(s:project_tree)
	bdel!
	return l:tree
endfunction

function! s:WriteZettelOverviewOfAllProjects()
	" get and parse all projects
	let l:projects = s:GetAllProjects('.')
	let l:projects['name'] = "All Projects"
	
	" encode data and write to file
	execute 'edit! data.json'
	execute 'normal! dG'
	call append(1, json_encode(l:projects))
	execute 'normal! 1dd'
	execute 'normal! 2dd'
	write!
	bdel!
	
	" call external zettel writer
	" let l:ret = system('node '.g:vimdoit_plugindir.'/src/write-zettels.js')
	" if trim(l:ret) != ""
	" 	echom l:ret
	" endif
endfunction
command! -nargs=0 WritePO	:call s:WriteZettelOverviewOfAllProjects()

function! s:WriteZettels()
	echom s:wproject_tree
	let l:data = json_encode(s:project_tree)		
	let l:ret = system('node '.g:vimdoit_plugindir.'/src/write-zettels.js -d '.shellescape(l:data))
	if trim(l:ret) != ""
		echom l:ret
	endif
endfunction
command! -nargs=0 WriteZettels	:call s:WriteZettels()

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"																Project Tree															 "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:DataInit()
	
	" the tree generated by the project-file parser	
	let s:project_tree = {
				\ 'id'			 : -1,
				\ 'type'		 : 'project',
				\ 'name'		 : 'Unknown Project',
				\ 'progress' : 0,
				\ 'level'		 : 0,
				\ 'sections' : [],
				\ 'tasks'		 : [],
				\ 'flags'		 : {},
				\	}
	
	" A stack to keep track of the nesting of (sub-)sections.
	" The top always points to the section to which
	" the currently parsed section should be added to.
	" Always use `DataStackPush`, `DataStackTop` and
	" `DataStackPop` to manipulate `s:sections_stack`.
	let s:sections_stack = [ s:project_tree ]
	
	" A stack to keep track of the nesting of tasks/notes.
	" The top always points to the section/task/note to which
	" the currently parsed task/note should be added to.
	" Always use `DataStackPush`, `DataStackTop` and
	" `DataStackPop` to manipulate `s:tasks_stack`.
	let s:tasks_stack = [ s:project_tree ]
endfunction

" Initial Init
call s:DataInit()

function! s:DataSaveJSON()
	echom "called DataSaveJSON"
	" remove 'OVERVIEW' section
	call filter(s:project_tree['sections'], 'v:val["name"] !=# "OVERVIEW"')
	let l:path = expand('%:p:h')
	let l:filename = substitute(expand('%:t'), '\v\.vdo', '', "")
	let l:fullname = l:path."/.".l:filename.".json"
	execute "edit! ".l:fullname
	execute 'normal! dG'
	call append(1, json_encode(s:project_tree))
	execute 'normal! 1dd'
	execute 'normal! 2dd'
	write!
  call system('node '.g:vimdoit_plugindir.'/src/generate-overviews/index.js -p '.l:fullname)
	
	let l:curbufname = bufname("%")
	let l:alternative = bufname("#")
	enew!
	execute "bwipeout! ".l:curbufname
	if l:alternative !=# ""
		execute "buffer ".l:alternative
	endif
endfunction
	
" ========================
" = Data Printer (Debug) =
" ========================

function! s:DataGetPadding(level)
	let l:r = range(a:level)
	let l:padding = ""
	for i in l:r 
		let l:padding .= "		"
	endfor

	return l:padding
endfunction

function! s:DataPrintSection(section, level)

	let l:padding   = s:DataGetPadding(a:level)
	let l:nextlevel = a:level + 1
	
	echom l:padding."# ".a:section['name']

	if len(a:section['tasks']) > 0
		echom l:padding."Tasks:"
		call map(a:section['tasks'], 's:DataPrintTask(v:val, l:nextlevel)')	
	endif

	if len(a:section['sections']) > 0
		echom l:padding."Sections:"
		call map(a:section['sections'], 's:DataPrintSection(v:val, l:nextlevel)')	
	endif
endfunction

function! s:DataPrintTask(task, level)
	
	let l:padding   = s:DataGetPadding(a:level + a:task['level'])
	let l:nextlevel = a:level
	
	echom l:padding."".a:task['name']." – ".a:task['level']
	
	if len(a:task['tasks']) > 0
		call map(a:task['tasks'], 's:DataPrintTask(v:val, l:nextlevel)')	
	endif
endfunction

function! s:DataPrint()
	call map(s:project_tree['sections'], 's:DataPrintSection(v:val, 0)')		
	" echom s:project_tree
endfunction

" ===========================================
" = Methods for generating the project tree =
" ===========================================

" ========================
" = Datastructure: Stack =
" ========================

function! s:DataStackPush(stack, object)
	call add(a:stack, a:object)
endfunction

function! s:DataStackTop(stack)
	let l:len = len(a:stack)
	return a:stack[l:len-1]
endfunction

function! s:DataStackPop(stack)
	let l:len = len(a:stack)
	call remove(a:stack, l:len-1)
endfunction

function! s:DataStackReset(stack)
	if len(a:stack) > 0
		unlet a:stack[0 : ]
	endif
endfunction

" Decides to pop some objects of `a:stack` according to `a:level`.
function! s:DataStackUpdate(stack, level)

	if len(a:stack) == 0
		return
	endif
	
	let l:top = s:DataStackTop(a:stack)
	
	if a:level <= l:top["level"]
		while l:top["level"] > a:level - 1
			
			call s:DataStackPop(a:stack)
			
			if len(a:stack) == 0
				return
			endif
			
			let l:top = s:DataStackTop(a:stack)
			
		endwhile
	endif
endfunction

" =======================
" = Datastructure: Tree =
" =======================

function! s:DataNewSection(name)
	let s:section = {
				\ 'id'					: -1,
				\ 'type'			  : 'section',
				\ 'name'        : a:name,
				\ 'start'				: -1,
				\ 'level'				: -1,
				\ 'end'					: -1,
				\ 'progress'		: 0,
				\ 'sections'	  : [],
				\ 'tasks'       : [],
				\ 'flags'				: {},
				\ }
	return s:section	
endfunction

function! s:DataNewTask(name, linenum, level)
	let s:task = {	
				\ 'id'	  		: -1,
				\ 'type'		 : 'task',
				\ 'name'	 	 : a:name,
				\ 'linenum'	 : a:linenum,
				\ 'level'		 : a:level,
				\ 'done'		 : 0,
				\ 'waiting'	 : 0,
				\ 'failed'	 : 0,
				\ 'blocking' : 0,
				\ 'tasks'		 : [],
				\ 'flags'		 : {},
				\ 'valid_syntax' : v:true,
				\ }
	return s:task
endfunction

" Notes are speciel types of tasks.
function! s:DataNewNote(name, linenum, level)
	let s:note = {	
				\ 'id'	   	: -1,
				\ 'type'		 : 'note',
				\ 'name'	 	 : a:name,
				\ 'linenum'	 : a:linenum,
				\ 'level'		 : a:level,
				\ 'done'		 : -1,
				\ 'tasks'	 	 : [],
				\ 'flags'		 : {},
				\ 'valid_syntax' : v:true,
				\ }
	return s:note
endfunction

" Links are speciel types of tasks.
function! s:DataNewLink(project, section, linenum, level)
	let s:link = {	
				\ 'id'	  	: -1,
				\ 'type'		 : 'link',
				\ 'project'	 : a:project,
				\ 'section'	 : a:section,
				\ 'linenum'	 : a:linenum,
				\ 'level'		 : a:level,
				\ 'flags'		 : {},
				\ }
	return s:link
endfunction

function! s:GetProjectType(flags)
	if !has_key(a:flags, 'tag')
		return 'project'
	endif

	for i in a:flags['tag']
		if i ==# '#sprint'
			return 'sprint'
		endif
	endfor

	return 'project'
	
endfunction

function! s:DataSetProject(name, flags)
	let s:project_tree['name']  = a:name
	let s:project_tree['flags'] = a:flags
	let s:project_tree['type']  = s:GetProjectType(a:flags)
endfunction

function! s:DataAddSection(name, start, level, flags)
	" create new section object
	let l:new = s:DataNewSection(a:name)
	let l:new['start'] = a:start
	let l:new['level'] = a:level
	let l:new['flags'] = a:flags
	" update sections stack according to level	
	call s:DataStackUpdate(s:sections_stack, l:new["level"])
	" add section as child
	let l:top = s:DataStackTop(s:sections_stack)
	call add(l:top['sections'], l:new)
	" add section as top of `s:sections_stack`
	call s:DataStackPush(s:sections_stack, l:new)
	" set section as top of `s:tasks_stack`
	call s:DataStackReset(s:tasks_stack)
	call s:DataStackPush(s:tasks_stack, l:new)
endfunction

" Returns the section with name = `a:name`.
" If no such section exists, returns an empty list.
function! s:DataGetSection(name)
	return filter(deepcopy(s:project_tree['sections']), 'v:val["name"] == "'.a:name.'"')
endfunction

function! s:DataGetFirstSection()
	return s:project_tree['sections'][0]
endfunction

function! s:DataGetProjectProgress()
	return s:project_tree['progress']
endfunction

" Updates the `end` of each Section according to it's successor's `start`
function! s:DataUpdateEndOfEachSection(section)
	
	let l:prev_section = {}
	
	for i in a:section
		
		if l:prev_section != {}
			let l:prev_section['end'] = i['start'] - 1
		endif

		if l:prev_section != {} && len(l:prev_section['sections']) > 0
			let l:last_section        = s:DataUpdateEndOfEachSection(l:prev_section['sections'])
			let l:last_section['end'] = i['start'] - 1
		endif
		
		let l:prev_section = i
	endfor
	
	return l:prev_section
endfunction

function! s:IsSubTask(t1, t2)
	if a:t1["level"] > a:t2["level"]
		return v:true
	else
		return v:false
	endif
endfunction

function! s:IsTaskWaiting(flags)
	if has_key(a:flags, "waiting_block") == 1
		if len(a:flags['waiting_block']) > 0
			return v:true
		else
			return v:false
		endif
	else
		return v:false
	endif
endfunction

function! s:IsTaskBlocking(flags)
	if has_key(a:flags, "block") == 1
		if len(a:flags['block']) > 0
			return v:true
		else
			return v:false
		endif
	else
		return v:false
	endif
endfunction

function! s:DataAddTask(name, linenum, level, flags, valid_syntax)
	
	let l:new = s:DataNewTask(a:name, a:linenum, a:level)	
	let l:new['flags']        = a:flags
	let l:new['done']         = s:IsTaskDone(a:linenum)
	let l:new['waiting']      = s:IsTaskWaiting(a:flags)
	let l:new['blocking']     = s:IsTaskBlocking(a:flags)
	let l:new['failed']       = s:IsTaskFailed(a:linenum)
	let l:new['valid_syntax'] = a:valid_syntax
	
	" set id as supplied in flag
	if has_key(a:flags, 'id') == v:true && len(a:flags['id']) != 0
		let l:new['id'] = a:flags['id']
	endif

	" update tasks stack according to level	
	call s:DataStackUpdate(s:tasks_stack, l:new["level"])
	
	" decide where to add task to (current section or current tasks)
	if len(s:tasks_stack) == 0
		let l:top = s:DataStackTop(s:sections_stack)
	else
		let l:top = s:DataStackTop(s:tasks_stack)
	endif
	
	call add(l:top['tasks'], l:new)

	" add task as top of `s:task_stack`
	call s:DataStackPush(s:tasks_stack, l:new)

	return l:new
endfunction

function! s:DataAddNote(name, linenum, level, flags, valid_syntax)
	
	let l:new = s:DataNewNote(a:name, a:linenum, a:level)	
	let l:new['flags']        = a:flags
	let l:new['valid_syntax'] = a:valid_syntax
	
	" set id as supplied in flag
	if has_key(a:flags, 'id') == v:true && len(a:flags['id']) != 0
		let l:new['id'] = a:flags['id']
	endif

	" update tasks stack according to level	
	call s:DataStackUpdate(s:tasks_stack, l:new["level"])
	
	" decide where to add note to (current section or current tasks)
	if len(s:tasks_stack) == 0
		let l:top = s:DataStackTop(s:sections_stack)
	else
		let l:top = s:DataStackTop(s:tasks_stack)
	endif
	
	call add(l:top['tasks'], l:new)

	" add link as top of `s:task_stack`
	call s:DataStackPush(s:tasks_stack, l:new)
endfunction

function! s:DataAddLink(project, section, linenum, level, flags)
	
	let l:new = s:DataNewLink(a:project, a:section, a:linenum, a:level)	
	let l:new['flags'] = a:flags
	
	" update tasks stack according to level	
	call s:DataStackUpdate(s:tasks_stack, l:new["level"])
	
	" decide where to add link to (current section or current tasks)
	if len(s:tasks_stack) == 0
		let l:top = s:DataStackTop(s:sections_stack)
	else
		let l:top = s:DataStackTop(s:tasks_stack)
	endif
	
	call add(l:top['tasks'], l:new)

	" add link as top of `s:task_stack`
	call s:DataStackPush(s:tasks_stack, l:new)
endfunction


" =========================================
" = Methods for computing additional data =
" =========================================

function! s:DataComputeProgress()
	call map([s:project_tree], "s:DataComputeProgressSection(v:val)")	
endfunction

function! s:DataComputeProgressSection(section)

	if a:section['name'] ==# "OVERVIEW"
		return a:section
	endif
	
	" compute progress of subsections
	if len(a:section['sections']) > 0
		call map(a:section['sections'], "s:DataComputeProgressSection(v:val)")
	endif

	" get the number of all subtasks and the number of done subtasks
	" in all subsections
	let l:info = { 'num' : 0, 'done' : 0 }
	call s:GetInfoAllSubsections(a:section, l:info)
	if l:info['done'] == 0 && l:info['num'] == 0
		let a:section['progress'] = 0
	else
		let a:section['progress'] = 1.0 * l:info['done'] / l:info['num']
	endif

	return a:section
endfunction

function! s:GetInfoAllSubsections(section, info)
	for i in a:section['tasks']
		call s:GetInfoAllSubtasks(i, a:info, v:false)
	endfor
	for i in a:section['sections']
		call s:GetInfoAllSubsections(i, a:info)
	endfor
endfunction

function! s:GetInfoAllSubtasks(task, info, parent)

	" skip links
	if a:task['type'] ==# 'link'
		return
	endif

	"skip notes
	if a:task['type'] ==# 'task'
		let a:info['num']	+= 1
		
		if a:parent == v:false
			" parent task is not done, check if current task is done
			let a:info['done'] += a:task['done'] == v:true ? 1 : 0
			let l:parent = a:task['done']
		else
			" parent task is done, therefore this task is also done
			let a:info['done'] += 1
			let l:parent = v:true
		endif
	else
		let l:parent = a:parent		
	endif
	
	for i in a:task['tasks']
		call s:GetInfoAllSubtasks(i, a:info, l:parent)
	endfor
endfunction

function! s:HasItemFlagSprint(item)
	if has_key(a:item['flags'], 'sprint') != 0 && len(a:item['flags']['sprint']) > 0
		return v:true
	else
		return v:false
	endif
endfunction

" return a flat list of all tasks filtered by `a:condition`
function! s:FilterTasks(item, list)

	if s:HasItemFlagSprint(a:item) == v:true
		call add(a:list['items'], a:item)
	endif

	for i in a:item['tasks']
		call s:FilterTasks(i, a:list)
	endfor
	
	if has_key(a:item, 'sections') == 0
		return
	endif
	
	for i in a:item['sections']
		call s:FilterTasks(i, a:list)
	endfor

endfunction

function! s:DataGetAllTasksAndNotes(item, list)

	if a:item['type'] == 'task' || a:item['type'] == 'note'
		call add(a:list['items'], a:item)
	endif

	for i in a:item['tasks']
		call s:DataGetAllTasksAndNotes(i, a:list)
	endfor
	
	if has_key(a:item, 'sections') == 0
		return
	endif
	
	for i in a:item['sections']
		call s:DataGetAllTasksAndNotes(i, a:list)
	endfor

endfunction


function! s:DataUpdateReferencesIsRefLocal(ref)
	" TODO
	return v:true
endfunction

function! s:DataUpdateReferencesLocalRef(ref)
	" does the section exist?	
	" NO: throw error; abort
	
	" add reference to section in `s:project_tree`
endfunction

function! s:DataAppendFlagDelimiter(linenum)
	let l:line = getline(a:linenum)
	call setline(a:linenum, l:line.' --')
endfunction

function! s:DataAddFlag(flag, linenum)
	" is there are delimiter?
	if s:HasLineFlagDelimiter(getline(a:linenum)) == v:false
		" append delimiter
		call s:DataAppendFlagDelimiter(a:linenum)
	endif
	
	" append flag
	let l:line = getline(a:linenum)
	call setline(a:linenum, l:line.' '.a:flag)
endfunction

function! s:GenerateID(len)
	return trim(system('date "+%s%N" | sha256sum'))[0:a:len-1]
endfunction

" works like grep, but also considers unsaved changes,
" whereas grep only works on the files written to disk.
function! s:GetNumOccurences(pat)
	" save stuff
	let l:save_buffer = bufname()
	let l:save_cursor = getcurpos()
	let l:save_cwd    = getcwd()
	let l:save_a      = @a
	" go to project root
	execute 'cd '.g:vimdoit_projectsdir
	" get list of all listed buffers
	let buffers = getbufinfo({'buflisted':1})	 
	" open all `.vdo` files, including hidden ones
	args ./**/*.vdo ./**/.*.vdo
	" clear register a
	let @a = ''
	" check if ID is already in use
	execute 'silent! bufdo global/'.a:pat.'/yank A'
	" save  result
	let l:res = @a
	" restore register a
	let @a = l:save_a
	" restore original buffer
	execute "buffer ".l:save_buffer
	" get list of all buffers to delete, except the ones which were previously listed
	let bdel = s:GetBuffersToDelete(buffers)
	" delete buffers
	call s:DeleteBuffers(bdel)
	" restore cursor
	call setpos('.', l:save_cursor)
	" restore working directory
	execute "cd ".l:save_cwd
	" return found occurences
	return len(split(l:res, '\n'))
endfunction

function! s:NewID()	
	" generate ID
	let l:id = s:GenerateID(8)
	" check if ID is already in use
	while s:GetNumOccurences('\v<0x'.l:id.'(\|\d+)?>') > 0
		let l:id = trim(system('echo '.l:id.' | sha256sum'))[0:7]
	endwhile 
	return l:id
endfunction

command! -nargs=? NewID	:call s:NewID()

function! s:DataAddID(ref)

	" `a:ref` is a section, therefore it has no `linenum` but `start` and `end`
	if has_key(a:ref, 'start')
		let l:linenum = a:ref['start'] + 1
	else
		let l:linenum = a:ref['linenum']
	endif
	
	let l:id				= s:NewID()
	let a:ref['id'] = l:id
	let l:id				= '0x'.l:id

	" actual adding of ID
	call s:DataAddFlag(l:id, l:linenum)
endfunction

function! s:DataHasID(ref)
	if a:ref['id'] != -1
		return v:true
	else
		return v:false
	endif
endfunction

function! s:DataCheckIDs()

	" get all tasks
	let l:tasks = { 'items' : [] }
	call s:DataGetAllTasksAndNotes(s:project_tree, l:tasks)
	
	" decide what to do
	for item in l:tasks['items']
		" has the task/section of the reference already an ID?
		if s:DataHasID(item) == v:false
			" no: create it
			call s:DataAddID(item)
		endif
	endfor
	
endfunction

function! s:DataFindChanges()
	
	redir => l:changedlines
	silent execute 'w !diff --unchanged-line-format="" --old-line-format="" --new-line-format=";\%dn" % -'
	redir END
	
	let l:split = split(l:changedlines, '')
	if len(l:split) == 0
		return []
	endif
	
	let l:lines = split(l:split[0], ';')
	call map(l:lines, 'getline(v:val)')
	return l:lines
endfunction

function! s:DataGetIDOfLine(line)
	let l:pattern = '\v0x(\x{8}(\|\d+)?)'
	let l:id    = []
	call substitute(a:line, l:pattern, '\=add(l:id, submatch(1))', 'g')
	
	if len(l:id) == 0
		return -1
	else
		return l:id[0]
	endif
endfunction

function! s:GetBuffersToDelete(buffers)

	let buflist   = getbufinfo({'buflisted':1})
	let to_delete = []

	for i in buflist
		let found = v:false
		for j in a:buffers
			if i['name'] ==# j['name']
				let found = v:true
			endif
		endfor

		if found == v:false
			call add(to_delete, i)
		endif
	endfor
				
	return to_delete	
	
endfunction

function! s:DeleteBuffers(buffers)
	for buf in a:buffers
		execute 'silent bdelete '.buf.bufnr
	endfor
endfunction

function! s:DataUpdateReferences()
	"save cursor
	let l:save_buffer = bufname()
	let l:save_cursor = getcurpos()
	let l:save_cwd    = getcwd()
	" go to projects root
	execute "cd ".g:vimdoit_projectsdir
	" make sure that all tasks/notes have an ID
	call s:DataCheckIDs()
	" get the changed lines
	let l:changedlines = s:DataFindChanges()
	" no changes, abort
	if len(l:changedlines) == 0 | return | endif
	" get list of all listed buffers
	let buffers = getbufinfo({'buflisted':1})	 
	" open all files
	args ./**/*.vdo
	args ./**/.*.vdo

	" update references of changed lines, if there are any
	for i in l:changedlines
		" get ID of line
		let l:id = substitute(s:DataGetIDOfLine(i), '\v\|', '\\\|', '')
		" get line without indendation
		let l:replace = substitute(i, '\v^\s*', '', 'g')
		" escaping of special characters
		let l:replace_esc = escape(l:replace, '~&$.*()|\{}[]<>')
		" line does not have an ID, so skip
		if l:id == -1 | continue | endif
		" actual updating of references
		execute 'silent! bufdo global/\v\s0x'.l:id.'(\s|$)/substitute/\v^\s*\zs.*\ze$/'.l:replace_esc.'/g'
		" execute 'silent! bufdo global/\v\s0x'.l:id.'(\s|$)/substitute/\V^\s\*\zs\.\*\ze$/'.l:replace.'/g'
		" check if line has a repetition, then update its auto-generated references
		if s:HasRepetition(i) == v:false
			continue
		endif
		" split replacement into three parts:
		"		a) everything after status and before the repetition
		"		b) everything after the repetition and before the id
		"		c) everything after the id
		let l:replace = substitute(l:replace, '\v^\s*-\s(\[.\])?', '', '')
		let l:split   = split(l:replace, '\v\{.*\}')
		let l:split_2 = split(l:split[1], '\v0x\x{8}')
		if len(l:split_2) == 1
			call add(l:split_2, '')
		endif
		let l:final = map([ l:split[0], l:split_2[0], l:split_2[1] ],  'escape(v:val, "~&$.*()|\{}[]<>")')
		" keep the auto-generated status,date and id by using a backreference in the substitution:
		execute 'silent! bufdo global/\v\s0x'.l:id.'\|\d+(\s|$)/substitute/\v^\s*-\s(\[.\])?\zs.*(\{.*\}).*(0x\x{8}\|\d+)(\s.*$|$)/'.l:final[0].'\2'.l:final[1].'\3'.l:final[2].'/g'
	endfor

	" save changed buffers
	execute 'silent! bufdo update'
	" restore original buffer
	execute "buffer ".l:save_buffer
	" get list of all buffers to delete, except the ones which were previously listed
	let bdel = s:GetBuffersToDelete(buffers)
	" delete buffers
	call s:DeleteBuffers(bdel)
	" restore cursor
	call setpos('.', l:save_cursor)
	" restore working directory
	execute "cd ".l:save_cwd
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"																		Drawer													     	"
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:DrawProjectStatistics()
	" check if there is already a line with progress
	if match(getline(2), '^Progress') != -1
		" yes: delete it
		call deletebufline(bufname(), 2)
	endif
	
	call append(1, "Progress: ".printf('%.2f%%', s:DataGetProjectProgress()*100))
endfunction

function! s:DrawComputeOverviewText(sections, text, num, padding)
	let l:j = 1
	let l:sep = a:num == "" ? '' : '.'
	let l:padding = a:padding."	"
	let l:text = a:text
	for i in a:sections
		let l:numstr = a:num.l:sep.l:j
		call add(l:text, l:padding.l:numstr.'. '.i['name'].' '.printf('[%.2f%%]', i['progress']*100))
		" recurse
		if len(i['sections']) > 0
			let l:text = s:DrawComputeOverviewText(i['sections'], l:text, l:numstr, l:padding)
		endif
		let l:j += 1
	endfor

	return l:text
endfunction

function! s:DrawSectionOverview()
	let l:overview = s:DataGetSection("OVERVIEW")
	
	" check if there is already a section 'OVERVIEW' in the document
	if l:overview == []
		" no, just get the drawing position
		let s:tmp = s:DataGetFirstSection()
		let l:draw_position = s:tmp['start']-1
		let l:sections = s:project_tree['sections']
	else
		" yes, delete it
		let l:overview      = l:overview[0]
		let l:draw_position = l:overview['start']-1
		" delete old overview
		call deletebufline(bufname(), l:overview['start'], l:overview['end'])
		let l:sections = filter(deepcopy(s:project_tree['sections']), 'v:val["name"] != "OVERVIEW"')
	endif
	
	" insert new overview

	let l:text = [ 
				\ "==============================================================================", 
				\ "<OVERVIEW>",
				\ "",
				\ ]	

	let l:text     = s:DrawComputeOverviewText(l:sections, l:text, "", "")
	call add(l:text, "")
	
	call append(l:draw_position, l:text)

endfunction

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"												 		Project-file Parser			                       "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:IsLineEmpty(line)
	if trim(a:line) == ""
		return v:true
	else
		return v:false
	endif
endfunction

function! s:IsLinenumSectionHeading(linenum)
	if s:IsLineSectionDelimiter(a:linenum - 1) || s:IsLineSubsectionDelimiter(a:linenum - 1)
		return v:true
	else
		return v:false
	endif
endfunction

function! s:IsLineSectionDelimiter(line)
	let l:pattern = '^===.*===$'
  let l:result  = match(a:line, l:pattern)
	
	if l:result == -1
		return v:false
	else
		return v:true
	endif
endfunction

function! s:IsLineSubsectionDelimiter(line)
	let l:pattern = '^---.*---$'
  let l:result  = match(a:line, l:pattern)
	
	if l:result == -1
		return v:false
	else
		return v:true
	endif
endfunction

function! s:IsLineTask(line)
	let l:pattern = '\v^\s*-\s\[.*\]\s.*$'
	let l:result  = match(a:line, l:pattern)
	
	if l:result == -1
		return v:false
	else
		return v:true
	endif
endfunction

function! s:IsLineNote(line)
	let l:pattern = '\v^\s*-\s.*$'
	let l:result  = match(a:line, l:pattern)
	
	if l:result == -1
		return v:false
	else
		return v:true
	endif
endfunction

function! s:IsLineLink(line)
	let l:pattern = '\v^\s*-\s\<[^\>]+\>$'
	let l:result  = match(a:line, l:pattern)
	
	if l:result == -1
		return v:false
	else
		return v:true
	endif
endfunction

function! s:HasLineFlagDelimiter(line)
	if a:line =~# '\v\s--(\s|$)'
		return v:true
	else
		return v:false
	endif
endfunction

function! s:ExtractProjectName(line)
	return s:ExtractSectionHeading(getline(a:line))
endfunction

function! s:ExtractProjectFlags(line)
	return s:ExtractSectionHeadingFlags(getline(a:line))
endfunction

function! s:ExtractWaitings(line)
	let l:pattern  = '\v\~(\x{8})'
	let l:waitings  = []
	call substitute(a:line, l:pattern, '\=add(l:waitings, submatch(1))', 'g')
	return l:waitings
endfunction

function! s:ExtractSectionHeading(line)
	let l:pattern  = '\v^\t*\<\zs.*\ze\>'
	let l:heading  = []
	call substitute(a:line, l:pattern, '\=add(l:heading, submatch(0))', 'g')

	if l:heading == []
		throw "ERROR: Heading not found!"
		return
	endif
	
	return trim(l:heading[0])
endfunction

function! s:ExtractSectionLevel(line)
	let l:pattern = '\v\zs\s*\ze[^\s]'
	let l:tabs    = []
	call substitute(a:line, l:pattern, '\=add(l:tabs, submatch(0))', 'g')
	return strlen(l:tabs[0])
endfunction

function! s:ExtractStartDateOfRepetition(line)
	let l:pattern = '\v\{.*\zs\d{4}-\d{2}-\d{2}\ze.*\|[a-z]{1,2}:.*\}'
	let l:startdate    = []
	call substitute(a:line, l:pattern, '\=add(l:startdate, submatch(0))', 'g')
	return trim(l:startdate[0])
endfunction

function! s:ExtractEndDateOfRepetition(line)
	let l:pattern = '\v\{.*\d{4}-\d{2}-\d{2}.*\|[a-z]{1,2}:.*\|\zs\d{4}-\d{2}-\d{2}\ze.*\}'
	let l:enddate    = []
	call substitute(a:line, l:pattern, '\=add(l:enddate, submatch(0))', 'g')

	if len(l:enddate) == 0
		return '2999-12-31'
	else
		return trim(l:enddate[0])
	endif
endfunction

function! s:ExtractTimeOfRepetition(line)
	let l:pattern = '\v\{.*\zs\d{2}:\d{2}\ze.*\}'
	let l:time    = []
	call substitute(a:line, l:pattern, '\=add(l:time, submatch(0))', 'g')

	if len(l:time) == 0
		return ''
	else
		return ' '.trim(l:time[0])
	endif
endfunction

function! s:ExtractRepetitionOperator(line)
	let l:pattern = '\v\{.*\|\zs[a-z]{1,2}\ze:.*\}'
	let l:operator    = []
	call substitute(a:line, l:pattern, '\=add(l:operator, submatch(0))', 'g')
	return trim(l:operator[0])
endfunction

function! s:ExtractRepetitionOperand(line)
	let l:pattern = '\v\{.*\|[a-z]{1,2}:\zs\d+\ze.*\}'
	let l:operand    = []
	call substitute(a:line, l:pattern, '\=add(l:operand, submatch(0))', 'g')
	return trim(l:operand[0])
endfunction

function! s:ExtractDate(line)
	let l:pattern = '\v\{.*\zs\d{4}-\d{2}-\d{2}\ze.*\}'
	let l:date    = []
	call substitute(a:line, l:pattern, '\=add(l:date, submatch(0))', 'g')
	return trim(l:date[0])
endfunction

function! s:ExtractDateExact(line)
	let l:pattern = '\v\{\zs\d{4}-\d{2}-\d{2}\ze\}'
	let l:date    = []
	call substitute(a:line, l:pattern, '\=add(l:date, submatch(0))', 'g')

	if len(l:date) == 0
		return '-1'
	else
		return trim(l:date[0])
	endif
endfunction

function! s:ExtractDateFull(line)
	let l:pattern = '\v\{.*\}'
	let l:datefull    = []
	call substitute(a:line, l:pattern, '\=add(l:datefull, submatch(0))', 'g')
	return trim(l:datefull[0])
endfunction

function! s:ExtractDateFuller(line)
	let l:pattern = '\v\zs\{.*\}\ze'
	let l:datefull    = []
	call substitute(a:line, l:pattern, '\=add(l:datefull, submatch(0))', 'g')
	return trim(l:datefull[0])
endfunction

function! s:ExtractDateId(line)
	let l:pattern = '\v0x\x{8}\|\zs\d+\ze'
	let l:dateid    = []
	call substitute(a:line, l:pattern, '\=add(l:dateid, submatch(0))', 'g')
	return trim(l:dateid[0])
endfunction

function! s:ExtractId(line)
	let l:pattern = '\v0x\zs\x{8}\ze'
	let l:id    = []
	call substitute(a:line, l:pattern, '\=add(l:id, submatch(0))', 'g')
	return trim(l:id[0])
endfunction

function! s:ExtractIdFull(line)
	let l:pattern = '\v0x\zs\x{8}(\|\d+)?\ze'
	let l:id    = []
	call substitute(a:line, l:pattern, '\=add(l:id, submatch(0))', 'g')
	return trim(l:id[0])
endfunction

function! s:ExtractTaskName(line)
	return substitute(a:line, '\v^\s*- \[.\]\s', '', '')
endfunction

function! s:ExtractNoteName(line)
	let l:pattern = '\v\s*-\s\zs.*\ze((--)|$)'
	let l:note    = []
	call substitute(a:line, l:pattern, '\=add(l:note, submatch(0))', 'g')
	return trim(l:note[0])
endfunction

function! s:ExtractLinkProject(line)
	let l:pattern = '\v^\s*-\s\<p:\zs[^;]+\ze[^\>]*\>$'
	let l:link    = []
	call substitute(a:line, l:pattern, '\=add(l:link, submatch(0))', 'g')
	return trim(l:link[0])
endfunction

function! s:ExtractLinkSection(line)
	let l:pattern = '\v^\s*-\s\<p:[^;]+;s:\zs[^;]+\ze[^\>]*\>$'
	let l:link    = []
	call substitute(a:line, l:pattern, '\=add(l:link, submatch(0))', 'g')

	if len(l:link) == 0
		return ''
	else
		return trim(l:link[0])
	endif
endfunction


function! s:ExtractTaskLevel(line)
	let l:pattern = '\v\zs\s*\ze-'
	let l:tabs    = []
	call substitute(a:line, l:pattern, '\=add(l:tabs, submatch(0))', 'g')
	return strlen(l:tabs[0])
endfunction

function! s:ExtractNoteLevel(line)
	return s:ExtractTaskLevel(a:line)	
endfunction

function! s:ExtractLinkLevel(line)
	return s:ExtractTaskLevel(a:line)	
endfunction

" TODO refactor using global Extract* and Has* functions
function! s:ExtractFlagsFromFlagRegion(region)

	let l:line = a:region
	
	let l:flags = {
				\ 'normal'				: [],
				\ 'sprint'				: [],
				\ 'block'					: [],
				\ 'waiting_block' : [],
				\ 'waiting_date'	: [],
				\ 'tag'						: [],
				\ 'id'						: [],
				\	}

	" extract sprint flags ('@sprint')
	let l:pattern = '\v\@[^ \t]+'
	let l:normal    = []
	call substitute(l:line, l:pattern, '\=add(l:flags["sprint"], submatch(0))', 'g')
	let l:line = substitute(l:line, l:pattern, '', 'g')
	
	" extract block flags ('$block')
	let l:pattern = '\v\$block'
	let l:normal    = []
	call substitute(l:line, l:pattern, '\=add(l:flags["block"], submatch(0))', 'g')
	let l:line = substitute(l:line, l:pattern, '', 'g')
	
	" extract waiting for block flags ('~42a4')
	let l:pattern = '\v\~\x{8}'
	let l:normal    = []
	call substitute(l:line, l:pattern, '\=add(l:flags["waiting_block"], submatch(0))', 'g')
	let l:line = substitute(l:line, l:pattern, '', 'g')
	
	" extract waiting for date flags ('-waiting=2020-07-08')
	let l:pattern = '\v-waiting\=\d{4}-\d{2}-\d{2}'
	let l:normal    = []
	call substitute(l:line, l:pattern, '\=add(l:flags["waiting_date"], submatch(0))', 'g')
	let l:line = substitute(l:line, l:pattern, '', 'g')
	
	" extract id flag ('0xa3c922ba')
	let l:pattern = '\v0x(\x{8})'
	let l:id = []
	call substitute(l:line, l:pattern, '\=add(l:id, submatch(1))', 'g')
	if len(l:id) > 0
		let l:flags["id"] = l:id[0]
	endif
	let l:line = substitute(l:line, l:pattern, '', 'g')
	
	"extract flag ordinary tag ('#tag')
	let l:pattern = '\v#[^ \t]*'
	let l:normal    = []
	call substitute(l:line, l:pattern, '\=add(l:flags["tag"], submatch(0))', 'g')
	let l:line = substitute(l:line, l:pattern, '', 'g')
	
	" extract normal flag ('-flag')
	let l:pattern = '\v-[^ \t]+'
	let l:normal    = []
	call substitute(l:line, l:pattern, '\=add(l:flags["normal"], submatch(0))', 'g')
	let l:line = substitute(l:line, l:pattern, '', 'g')

	return l:flags
	
endfunction

function! s:ExtractSectionHeadingFlags(line)
	
	" remove section heading
	" everything remaining is the flag region
	let l:line = substitute(a:line, '\v^.*\>', '', '') 

	" no flags
	if strlen(trim(l:line)) == 0
		return {}
	endif

	" extract them
	return s:ExtractFlagsFromFlagRegion(l:line)
endfunction

function! s:ExtractTaskFlags(line)

	" does the task have any flags?
	if s:HasTaskFlags(a:line) == v:false
		return {}
	endif
	
	" remove everything which is not the flag region
	let l:line = substitute(a:line, '\v^.*--\s', '', '') 

	" extract them
	return s:ExtractFlagsFromFlagRegion(l:line)
endfunction

function! s:ExtractNoteFlags(line)
	return s:ExtractTaskFlags(a:line)
endfunction

function! s:HasTaskFlags(line)
	let l:pattern = '\v\s--\s'
	if match(a:line, l:pattern) == -1
		return v:false
	else
		return v:true
	endif
endfunction

function! s:IsTaskFailed(linenum)
	let l:line = getline(a:linenum)
	let l:pattern = '\v\s*-\s\[F\]\s.*$'
	if match(l:line, l:pattern) == -1
		return v:false
	else
		return v:true
	endif
endfunction

function! s:IsTaskDone(linenum)
	let l:line = getline(a:linenum)
	let l:pattern = '\v\s*-\s\[x\]\s.*$'
	if match(l:line, l:pattern) == -1
		return v:false
	else
		return v:true
	endif
endfunction

""""""""""""""""""""""""""
"				Validation			 "
""""""""""""""""""""""""""

function! s:ValidateStartDate(start, line)
	if a:start !~# '\v\d{4}-\d{2}-\d{2}'
		echoe "Invalid Start Date in: ".a:line
		return v:false
	else
		return v:true
	endif
endfunction

function! s:ValidateEndDate(end, line)
	if a:start !~# '\v\d{4}-\d{2}-\d{2}'
		echoe "Invalid End Date in: ".a:line
		return v:false
	else
		return v:true
	endif
endfunction

function! s:ValidateTime(time, line)
	if a:start !~# '\v\d{2}:\d{2}'
		echoe "Invalid Time in:".a:line
		return v:false
	else
		return v:true
	endif
endfunction

function! s:ValidateOperator(operator, line)
	let valid_operators = ['y', 'mo', 'w', 'd']
	if s:IsInList(a:operator, valid_operators) == v:false
		echoe "Invalid Operator in:".a:line
		return v:false
	else
		return v:true
	endif
endfunction

function! s:ValidateOperand(operand, line)
	if a:operand !~# '\v\d+'	
		echoe "Invalid Operand in:".a:line
		return v:false
	else
		return v:true
	endif
endfunction

function! s:ValidateDateNumber(line)
	let l:pattern = '\v\{.{-}\}'
	let l:dates    = []
	call substitute(a:line, l:pattern, '\=add(l:dates, submatch(0))', 'g')
	if len(l:dates) > 1
		return v:true
	else
		return v:false
	endif
endfunction

function! s:ValidateTask(line)
	" remove everyhing between ``
	let line = substitute(a:line, '\v`[^`]{-}`', '', 'g')
	
	" check if the task has more than one date (date or repetition)
	if s:ValidateDateNumber(line) == v:true
		echo "ERROR"
		throw "Task/Note has multiple dates: ".a:line
	endif

	" check if the task has a date or repetition
	if s:HasDateOrRepetition(line) == v:true

		let date = s:ExtractDateFuller(line)
		let pass = v:false

		" check if it is a valid date
		if date =~# '\v\{((Mon|Tue|Wed|Thu|Fri|Sat|Sun): )?\d{4}-\d{2}-\d{2}\}'
			let pass = v:true
		" check if it is a valid date with time
		elseif date =~# '\v\{((Mon|Tue|Wed|Thu|Fri|Sat|Sun): )?\d{4}-\d{2}-\d{2} \d{2}:\d{2}\}'
			let pass = v:true
		" check if it is a valid repetition (case 1)
		elseif date =~# '\v\{((Mon|Tue|Wed|Thu|Fri|Sat|Sun): )?\d{4}-\d{2}-\d{2}\|(y|mo|w|d):\d+\}'
			let pass = v:true
		" check if it is a valid repetition (case 1 with time)
		elseif date =~# '\v\{((Mon|Tue|Wed|Thu|Fri|Sat|Sun): )?\d{4}-\d{2}-\d{2}\|(y|mo|w|d):\d+\ \d{2}:\d{2}\}'
			let pass = v:true
		" check if it is a valid repetition (case 2)
		elseif date =~# '\v\{((Mon|Tue|Wed|Thu|Fri|Sat|Sun): )?\d{4}-\d{2}-\d{2}\|(y|mo|w|d):\d+\|\d{4}-\d{2}-\d{2}\}'
			let pass = v:true
		" check if it is a valid repetition (case 2 with time)
		elseif date =~# '\v\{((Mon|Tue|Wed|Thu|Fri|Sat|Sun): )?\d{4}-\d{2}-\d{2}\|(y|mo|w|d):\d+\|\d{4}-\d{2}-\d{2} \d{2}:\d{2}\}'
			let pass = v:true
		endif

		if pass == v:false
			echoe "Task has an invalid date or repetition: ".a:line
			return v:false
		endif
	
	endif

	return v:true
	
endfunction

" Iterates over every line of the file exactly once!
command! ParseFile :call s:ParseProjectFile()
function! s:ParseProjectFile()
	
	call s:DataInit()

	try
	
		let l:cur_line_num   = 0
		let l:total_line_num = line('$')

		" some flags
		let l:is_line_section_heading    = v:false
		let l:is_line_subsection_heading = v:false
		
		let l:i = 1
		while l:i <= l:total_line_num

			let l:line = getline(l:i)

			" skip empty lines
			if s:IsLineEmpty(l:line) == v:true
				let l:i += 1
				continue
			endif

			" is this the first line?
			if l:i == 1
				let l:project_name  = s:ExtractProjectName(l:i)
				let l:project_flags = s:ExtractProjectFlags(l:i)
				call s:DataSetProject(l:project_name, l:project_flags)
				
				let l:i += 1
				continue
			endif

			" is line a Section Delimiter?
			if s:IsLineSectionDelimiter(l:line) == v:true
				" yes: then next line contains the Section Heading
				let l:section_name  = s:ExtractSectionHeading(getline(l:i+1))
				let l:section_level = 1
				let l:flags         = s:ExtractSectionHeadingFlags(getline(l:i+1))
				call s:DataAddSection(l:section_name, l:i, section_level, l:flags)
				
				let l:i += 2
				continue
			endif
			
			" is line a Subsection Delimiter?
			if s:IsLineSubsectionDelimiter(l:line) == v:true
				" yes: then next line contains the Section Heading
				let l:section_name  = s:ExtractSectionHeading(getline(l:i+1))
				let l:section_level = 2 + s:ExtractSectionLevel(getline(l:i+1))
				let l:flags         = s:ExtractSectionHeadingFlags(getline(l:i+1))
				call s:DataAddSection(l:section_name, l:i, section_level, flags)
				
				let l:i += 2
				continue
			endif
			
			" is line a Task?	
			if s:IsLineTask(l:line) == v:true
				let l:task_name  = s:ExtractTaskName(l:line)
				let l:task_level = s:ExtractTaskLevel(l:line)
				let l:flags      = s:ExtractTaskFlags(l:line)
				let l:newtask    = s:DataAddTask(l:task_name, l:i, l:task_level, l:flags, s:ValidateTask(l:line))
				let l:i += 1
				continue
			endif
			
			" is line a Note?	
			if s:IsLineNote(l:line) == v:true
				let l:note_name   = s:ExtractNoteName(l:line)
				let l:note_level  = s:ExtractNoteLevel(l:line)
				let l:flags				= s:ExtractNoteFlags(l:line)
				call s:DataAddNote(l:note_name, l:i, l:note_level, l:flags, s:ValidateTask(l:line))
				let l:i += 1
				continue
			endif

			" is line a Link?
			if s:IsLineLink(l:line) == v:true
				let l:link_project = s:ExtractLinkProject(l:line)
				let l:link_section = s:ExtractLinkSection(l:line)
				let l:link_level   = s:ExtractLinkLevel(l:line)
				call s:DataAddLink(l:link_project, l:link_section, l:i, l:link_level, {})
				let l:i += 1
				continue
			endif

			let l:i += 1
		endwhile

		let l:last_section        = s:DataUpdateEndOfEachSection(s:project_tree["sections"])
		let l:last_section['end'] = line('$')

	catch
		echom "vimdoit:  Exception  in ".v:throwpoint.":"
		echom v:exception
	endtry

endfunction

function! s:AfterProjectChange()

	try

		" skip when this is a datefile
		let basename = expand('%:t:r')
		if basename =~# '\v\..*-date'
			return
		endif
		
		call s:ParseProjectFile()
		call s:DataUpdateReferences()
		call s:ParseProjectFile() " yes again
		call s:DataComputeProgress()
		call s:DrawSectionOverview()
		call s:DrawProjectStatistics()
		" call s:DataSaveJSON()

	catch
		echom "vimdoit:  Exception  in ".v:throwpoint.":"
		echom "   ".v:exception	
	endtry
	
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                        Quickfix Manipulation                          "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:GetQfTitle()
	if exists("w:quickfix_title")
		return w:quickfix_title
	else
		copen
		return w:quickfix_title
	endif
endfunction

function! s:HasQfTitleKey(title, key)
	if a:title =~# '\v\| '.a:key.': .*'
		return v:true
	else
		return v:false
	endif
endfunction

function! s:ModifyQfTitle(title, action, key, value)

	if a:action ==# 'add'
		if s:HasQfTitleKey(a:title, a:key) == v:true
			" modify
			return substitute(a:title, '\v'.a:key.': .*($|\|)', a:key.': '.a:value, '')	
		else
			" append
			return a:title." | ".a:key.": ".a:value
		endif
	elseif a:action ==# 'remove'
		" remove
	endif
	
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                              Sorting                                  "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


function! s:SortQuickfix()
	let selections = [
				\ 'priority',
				\ 'project',
				\ 'date',
				\ 'due date (only projects)',
				\ 'start date (only projects)',
				\ 'completion date (only projects)',
				\ ]
	let selections_dialog = [
				\ '&priority',
				\ 'p&roject',
				\ '&date',
				\ 'd&ue date (only projects)',
				\ '&start date (only projects)',
				\ '&completion date (only projects)',
				\ ]
	let input = confirm('Sort Quickfix List by', join(selections_dialog, "\n"))
	
	let l:qf = getqflist()
	let title = s:GetQfTitle()

	if selections[input-1] ==# 'priority'
		echom "Sorting by Priority."
		call sort(l:qf, 's:CmpQfByPriority')
		let title = s:ModifyQfTitle(title, 'add', 'sort', 'priority')
	elseif selections[input-1] ==# 'project'
		call sort(l:qf, 's:CmpQfByProject')
		echom "Sorting by Project"
		let title = s:ModifyQfTitle(title, 'add', 'sort', 'project')
	elseif selections[input-1] ==# 'date'
		call sort(l:qf, 's:CmpQfByDate')
		echom "Sorting by Date"
		let title = s:ModifyQfTitle(title, 'add', 'sort', 'date')
	elseif selections[input-1] ==# 'due date (only projects)'
		if g:vimdoit_quickfix_type ==# 'project'
			call sort(l:qf, 's:CmpQfByDueDate')
			echom "Sorting by Due Date (Only Projects)"
			let title = s:ModifyQfTitle(title, 'add', 'sort', 'due date')
		else
			echoe "Quickfix List is not of type project."	
			return
		endif
	elseif selections[input-1] ==# 'start date (only projects)'
		if g:vimdoit_quickfix_type ==# 'project'
			call sort(l:qf, 's:CmpQfByStartDate')
			echom "Sorting by Start Date (Only Projects)"
			let title = s:ModifyQfTitle(title, 'add', 'sort', 'start date')
		else
			echoe "Quickfix List is not of type project."	
			return
		endif
	elseif selections[input-1] ==# 'completion date (only projects)'
		if g:vimdoit_quickfix_type ==# 'project'
			call sort(l:qf, 's:CmpQfByCompletionDate')
			echom "Sorting by Completion Date (Only Projects)"
			let title = s:ModifyQfTitle(title, 'add', 'sort', 'completion date')
		else
			echoe "Quickfix List is not of type project."	
			return
		endif
	endif
	
	" replace list
	call setqflist(l:qf, 'r')	
	
endfunction

function! s:GetNumExclamations(str)
	let l:pattern  = '\v!'
	let l:marks  = []
	call substitute(a:str, l:pattern, '\=add(l:marks, submatch(0))', 'g')
	return len(l:marks)
endfunction

function! s:CmpQfByPriority(e1, e2)
	let [t1, t2] = [s:GetNumExclamations(a:e1.text), s:GetNumExclamations(a:e2.text)]
	return t1 ># t2 ? -1 : t1 ==# t2 ? 0 : 1
endfunction

function! s:CmpQfByProject(e1, e2)
	let [t1, t2] = [bufname(a:e1.bufnr), bufname(a:e2.bufnr)]
	return t1 ># t2 ? 1 : t1 ==# t2 ? 0 : -1
endfunction

function! s:GetDateOnly(str)
	let l:pattern  = '\v\{.*\zs(\d{4}-\d{2}-\d{2})\ze.*\}'
	let l:date  = []
	call substitute(a:str, l:pattern, '\=add(l:date, submatch(0))', 'g')

	if len(l:date) != 0
		return trim(l:date[0])
	else
		return v:false
	endif
endfunction

function! s:GetDateAndTime(str)
	let l:pattern  = '\v\{.*\zs(\d{4}-\d{2}-\d{2}).*(\d{2}:\d{2})?\ze\}'
	let l:date  = []
	call substitute(a:str, l:pattern, '\=add(l:date, submatch(0))', 'g')

	if len(l:date) != 0
		return trim(l:date[0])
	else
		return v:false
	endif
endfunction

function! s:CmpQfByDate(e1, e2)
	let [t1, t2] = [s:GetDateAndTime(a:e1.text), s:GetDateAndTime(a:e2.text)]
	return t1 ># t2 ? 1 : t1 ==# t2 ? 0 : -1
endfunction

function! s:CmpQfById(e1, e2)
	let [t1, t2] = [s:ExtractIdFull(a:e1.text), s:ExtractIdFull(a:e2.text)]
	return t1 ># t2 ? 1 : t1 ==# t2 ? 0 : -1
endfunction

function! s:GetDueDate(str)
	let l:pattern  = '\v\%\zs(\d{4}-\d{2}-\d{2})\ze'
	let l:date  = []
	call substitute(a:str, l:pattern, '\=add(l:date, submatch(0))', 'g')

	if len(l:date) != 0
		return trim(l:date[0])
	else
		return v:false
	endif
endfunction

function! s:CmpQfByDueDate(e1, e2)
	let [t1, t2] = [s:GetDueDate(a:e1.text), s:GetDueDate(a:e2.text)]
	return t1 ># t2 ? 1 : t1 ==# t2 ? 0 : -1
endfunction

function! s:GetStartDate(str)
	let l:pattern  = '\v\^\zs(\d{4}-\d{2}-\d{2})\ze'
	let l:date  = []
	call substitute(a:str, l:pattern, '\=add(l:date, submatch(0))', 'g')

	if len(l:date) != 0
		return trim(l:date[0])
	else
		return v:false
	endif
endfunction

function! s:CmpQfByStartDate(e1, e2)
	let [t1, t2] = [s:GetStartDate(a:e1.text), s:GetStartDate(a:e2.text)]
	return t1 ># t2 ? 1 : t1 ==# t2 ? 0 : -1
endfunction

function! s:GetCompletionDate(str)
	let l:pattern  = '\v\$\zs(\d{4}-\d{2}-\d{2})\ze'
	let l:date  = []
	call substitute(a:str, l:pattern, '\=add(l:date, submatch(0))', 'g')

	if len(l:date) != 0
		return trim(l:date[0])
	else
		return v:false
	endif
endfunction

function! s:CmpQfByCompletionDate(e1, e2)
	let [t1, t2] = [s:GetCompletionDate(a:e1.text), s:GetCompletionDate(a:e2.text)]
	return t1 ># t2 ? 1 : t1 ==# t2 ? 0 : -1
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                              Grepping                                 "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:GrepProjectsByTag(tag, path)

	call vimdoit_utility#SaveOptions()
	
	execute "cd ".a:path

	let &grepprg='rg --vimgrep --pre '.g:vimdoit_plugindir.'/scripts/pre-head.sh'
	
	if a:tag ==# 'all'
		let pattern = '"^.*$"'
		let title = "projects: all"
	elseif a:tag ==# 'not tagged'
		let pattern = '^\<.*\>[[:space:]]*$'
		let title = "projects: not tagged"
	elseif a:tag ==# 'not complete or cancelled or archived'
		let pattern = '"\#complete\|\#cancelled\|\#archived"'
		let &grepprg='rg --vimgrep --invert-match --pre '.g:vimdoit_plugindir.'/scripts/pre-head.sh'
		let title = "projects: not complete or cancelled or archived"
	else
		let pattern = '"^<.*>.*\#'.a:tag.'"'
		let title = "projects: #".a:tag
	endif

	" grep
	execute 'grep! --type-add '"vimdoit:*.vdo"' -t vimdoit '.pattern.' ' | copen
	
	" sort by priority
	let l:qf  = getqflist()
	call sort(l:qf, 's:CmpQfByPriority')
	let title = s:ModifyQfTitle(title, 'add', 'sort', 'priority')
	call setqflist(l:qf, 'r')	
	let g:vimdoit_quickfix_type = 'project'
	call s:SetQfSyntax()

	call vimdoit_utility#RestoreOptions()
endfunction
command! -nargs=? GrepFocused	:call s:GrepProjectsByTag()

function! s:GrepTasksWithInvalidAppointment(path)

	call vimdoit_utility#SaveCfStack()
	call vimdoit_utility#SaveOptions()

	" set grep format
	call s:SetGrep()
	
	if a:path ==# '%'
		let datefile = s:GetDatefileName()
		let file = '% '.datefile
	else
		let file = ''
		execute "cd ".a:path
	endif	
	
	" 1. grep all appointments
	let pattern = "\\{.*\\}"
	execute 'silent! grep! --type-add '"vimdoit:*.vdo"' -t vimdoit "'.pattern.'" '.file
	let l:qf_all = getqflist()

	if len(l:qf_all) == 0
		call vimdoit_utility#RestoreCfStack()
		call vimdoit_utility#RestoreOptions()
		call s:RestoreGrep()
		return
	endif


	" 2. grep all valid appointments
	let pattern = "\\{.*\\d{4}-\\d{2}-\\d{2}.*\\}"
	execute 'silent! grep! --type-add '"vimdoit:*.vdo"' -t vimdoit "'.pattern.'" '.file | copen
	let l:qf_valid = getqflist()

	if len(l:qf_valid) == 0
		call vimdoit_utility#RestoreCfStack()
		call vimdoit_utility#RestoreOptions()
		call s:RestoreGrep()
		return
	endif

	" 3. filter valid appointments from all
	let l:qf_new = []
	for d in l:qf_all

		let l:found = v:false
		
		for e in l:qf_valid
			if e.text ==# d.text
				let l:found = v:true
			endif
		endfor

		if l:found == v:false
			call add(l:qf_new, d)
		endif

	endfor
	
	call vimdoit_utility#RestoreCfStack()
	
	" push new list
	" call setqflist(l:qf_new, 'a', {'title' : 'tasks: invalid appointment'})
	call setqflist(l:qf_new, 'a')
	
	call vimdoit_utility#RestoreOptions()
	call s:RestoreGrep()
endfunction

function! s:HasRange(text)
	if a:text =~# '\v\{.*\d{4}-\d{2}-\d{2}.*\}-\{.*\d{4}-\d{2}-\d{2}.*\}'		
		return v:true
	else
		return v:false
	endif
endfunction

function! s:HasDateOrRepetition(text)
	if a:text =~# '\v\{.*\}'		
		return v:true
	else
		return v:false
	endif
endfunction

function! s:HasRepetition(text)
	" check if entry has repetition
	if a:text =~# '\v\{.*\|[a-z]{1,2}:.*\}'		
		return v:true
	else
		return v:false
	endif
endfunction

function! s:NicenQfByDate(qf)
	
	let idx = 0
	let day_prev = ''
	let week_prev = ''
	let month_prev = ''
	let year_prev = ''
	while idx < len(a:qf)

		let date = s:ExtractDate(a:qf[idx].text)
		let day = trim(system('date --date='.date.' +%A'))
		let week = trim(system('date --date='.date.' +%V'))
		let month = trim(system('date --date='.date.' +%B'))
		let year = trim(system('date --date='.date.' +%Y'))

		let inc = 1
		let insert = []

		if day_prev !=# day
			call add(insert, day.', '.date.':')
			call add(insert, '')
		endif
		
		if week_prev !=# week
			call add(insert, '')
			call add(insert, '--------------------------------------')
			call add(insert, '-							Woche '.week.'	 					  -')
			call add(insert, '--------------------------------------')
			call add(insert, '')
		endif
		
		if month_prev !=# month
			call add(insert, '')
			call add(insert, '======================================')
			call add(insert, '=						'.month.' '.year.'						=')
			call add(insert, '======================================')
			call add(insert, '')
		endif
		
		for i in insert
			call insert(a:qf, {'text' : i}, idx)
			let inc = inc + 1
		endfor

		let idx = idx + inc
		let day_prev = day
		let week_prev = week
		let month_prev = month
		let year_prev = year
	endwhile
	
endfunction

function! s:GrepTasksByStatus(status, path)

	call vimdoit_utility#SaveOptions()
	call s:SetGrep()

	if a:path ==# '%'
		let datefile = s:GetDatefileName()
		if filereadable(datefile) == v:true
			let file = '% '.datefile
		else
			let file = '%'
		endif
	else
		let file = ''
		execute "cd ".a:path
	endif	
	
	let pattern = ""

	if a:status ==# 'all'
		let pattern = "\\- \\[.\\]"
		let title = 'tasks: all'
	elseif a:status ==# 'todo'
		let pattern = "\\- \\[ \\]" 
		let title = 'tasks: todo'
	elseif a:status ==# 'done'
		let pattern = "\\- \\[x\\]"
		let title = 'tasks: done'
	elseif a:status ==# 'failed'
		let pattern = "\\- \\[F\\]"
		let title = 'tasks: failed'
	elseif a:status ==# 'cancelled'
		let pattern = "\\- \\[-\\]"
		let title = 'tasks: cancelled'
	elseif a:status ==# 'next'
		let pattern = "[\\#]next"
		let title = 'tasks: #next'
	elseif a:status ==# 'current'
		let pattern = "[\\#]cur"
		let title = 'tasks: #cur'
	elseif a:status ==# 'waiting'
		let pattern = "~\\x{4}"
		let title = 'tasks: waiting'
	elseif a:status ==# 'block'
		let pattern = "[$]\\x{4}"
		let title = 'tasks: block'
	elseif a:status ==# 'scheduled'
		let pattern = "\\{.*\\}"
		let title = 'tasks: scheduled'
	elseif a:status ==# 'appointment'
		let pattern = "\\{\\s*\\d{4}-\\d{2}-\\d{2}(\\s*\\d{2}:\\d{2})?\\s*\\}"
		let title = 'tasks: appointment'
	elseif a:status ==# 'repetition'
		let pattern = "\\{\\s*\\d{4}-\\d{2}-\\d{2}\\\\|[a-z]{1,2}:.*\\}"
		let title = 'tasks: repetition'
	endif
	
	execute 'silent! grep! --pre '.g:vimdoit_plugindir.'/scripts/pre-project.sh --type-add '"vimdoit:*.vdo"' -t vimdoit "'.pattern.'" '.file | copen

	let l:qf = getqflist()

	if a:status ==# 'appointment'
		" sort by date
		call sort(l:qf, 's:CmpQfByDate')
		let title = s:ModifyQfTitle(title, 'add', 'sort', 'date')
		let g:vimdoit_quickfix_type = 'appointment'
	else
		" sort by priority
		call sort(l:qf, 's:CmpQfByPriority')
		let title = s:ModifyQfTitle(title, 'add', 'sort', 'priority')
		let g:vimdoit_quickfix_type = 'task'
	endif
	
	" push list
	call setqflist(l:qf, 'r')	
	call s:SetQfSyntax()

	call vimdoit_utility#RestoreOptions()
	call s:RestoreGrep()
endfunction

function! s:GrepProjects(all)

	if a:all == v:true
		let path = g:vimdoit_projectsdir
	else
		let path = getcwd()
	endif

	let path_nicened = substitute(path, '\v'.g:vimdoit_projectsdir, '', '')

	if path_nicened ==# ''
		let path_nicened = '/'
	endif

	let selections = [
				\ 'all',
				\ 'active',
				\ 'focus',
				\ 'complete',
				\ 'cancelled',
				\ 'archived',
				\ 'not complete or cancelled or archived',
				\ 'not tagged',
				\ ]
	let selections_dialog = [
				\ '&all',
				\ 'ac&tive',
				\ '&focus',
				\ '&complete',
				\ 'ca&ncelled',
				\ 'a&rchived',
				\ 'not co&mplete or cancelled or archived',
				\ 'n&ot tagged',
				\ ]
	
	let input  = confirm('Searching Projects in '.shellescape(path_nicened).'', join(selections_dialog, "\n"))
	call s:GrepProjectsByTag(selections[input-1], path)
	
endfunction

function! s:GrepTasks(where)
	
	if a:where ==# 'project'
		let path = '%'
	elseif a:where ==# 'area'
		let path = getcwd()
	else
		let path = g:vimdoit_projectsdir
	endif
	
	let path_nicened = substitute(path, '\v'.g:vimdoit_projectsdir, '', '')

	if path_nicened ==# ''
		let path_nicened = '/'
	endif

	let selections = [
				\ 'all',
				\ 'todo',
				\ 'done',
				\ 'failed',
				\ 'cancelled',
				\ 'next',
				\ 'current',
				\ 'waiting',
				\ 'block',
				\ 'scheduled',
				\ 'appointment',
				\ 'repetition',
				\ 'invalid appointment',
				\ ]
	let selections_dialog = [
				\ '&all',
				\ '&todo',
				\ '&done',
				\ '&failed',
				\ '&cancelled',
				\ '&next',
				\ 'cu&rrent',
				\ '&waiting',
				\ '&block',
				\ '&scheduled',
				\ 'a&ppointment',
				\ 'r&epetition',
				\ '&invalid appointment',
				\ ]
	
	let input = confirm('Searching Tasks in '.shellescape(path_nicened).'', join(selections_dialog, "\n"))

	if selections[input-1] ==# 'invalid appointment'
		call s:GrepTasksWithInvalidAppointment(path)
	else
		call s:GrepTasksByStatus(selections[input-1], path)
	endif
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                               Filtering                               "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:SetQfSyntax()
	
	if exists('w:quickfix_title') == v:false
		return
	endif
	
	" :set conceallevel=2 concealcursor=nc
	syntax match qfFileName "\v^.{-}\|\d+\scol\s\d+\|" conceal
	syntax match Bars "\v^\|\|" conceal

	syntax match CalendarDateAndTime "\v\w*, \d{4}-\d{2}-\d{2}:"
	highlight link CalendarDateAndTime Operator

	syntax match CalendarText "\v(\s{3,}\w+\s\d+\s{3,})" contained
	highlight link CalendarText Operator
	syntax match CalendarWeek "\v(-{38}|\={38})"
	syntax match CalendarWeek "\v\s(-|\=)(\s{3,}\w+\s\d+\s{3,})(-|\=)$" contains=CalendarText
	highlight link CalendarWeek Identifier
	
	syntax match SectionHeadlineDelimiter "\v\<" contained conceal
	syntax match SectionHeadlineDelimiter "\v\>" contained conceal
	syntax match SectionHeadline "\v\<[^\>]*\>" contains=SectionHeadlineDelimiter
	highlight link SectionHeadline Operator
	highlight link SectionHeadlineDelimiter Comment
	syntax region FlagRegionHeadline start="\v\<[^\>]*\>" end="$" contains=Flag,FlagDelimiter,FlagBlock,FlagWaiting,FlagInProgress,FlagSprint,FlagTag,FlagID,SectionHeadline
	
	" Percentages
	syntax match Percentages "\v\[.*\%\]"
	highlight link Percentages Comment
	" Exclamation Mark
	syntax match ExclamationMark "\v!+"
	highlight link ExclamationMark Tag
	" Info
	syntax match Info "\v\u+[?!]*(\s\u+[?!]*)*:"
	highlight link Info Todo
	" Code
	syntax match Code "\v`.{-}`"
	highlight link Code Comment
	" Strings
	syntax match VimdoitString "\v[ \t]\zs['"].{-}['"]\ze[ \t,.!:\n]" contains=SingleSinglequote
	highlight link VimdoitString String
	" Time
	syntax match Appointment "\v\{.{-}\}"
	highlight link Appointment Constant
	" URLs
	syntax match URL `\v<(((https?|ftp|gopher)://|(mailto|file|news):)[^' 	<>"]+|(www|web|w3)[a-z0-9_-]*\.[a-z0-9._-]+\.[^' 	<>"]+)[a-zA-Z0-9/]`
	highlight link URL String
	" Flag Delimiter ('--')
	syntax match FlagDelimiter "\v\s--\s" contained
	highlight link FlagDelimiter Comment
	" Flag Normal ('-flag')
	syntax match Flag "\v\zs-.*\ze\s" contained
	highlight link Flag Comment
	" Flag Sprint ('@sprint')
	syntax match FlagSprint '\v\@[^ \t]+'
	syntax match FlagSprint "\v\@today" contained
	syntax match FlagSprint "\v\@week" contained
	highlight link FlagSprint Constant
	" Flag Block ('$23')
	syntax match FlagBlock "\v\$\d+" contained
	highlight link FlagBlock Orange
	" Flag Waiting For Block ('~23')
	syntax match FlagWaiting "\v\~\d+" contained
	highlight link FlagWaiting String
	" Flag ID ('0x8c3d19d5')
	syntax match FlagID "\v0x\x{8}(\|\d+)?" contained conceal
	highlight link FlagID NerdTreeDir
	" Flag ordinary tag ('#SOMESTRING')
	syntax match FlagTag "\v#[^ \t]*" contained
	highlight link FlagTag Identifier
	" Flag Region
	syntax region FlagRegion start="\v\s--\s" end="$" contains=Flag,FlagDelimiter,FlagBlock,FlagWaiting,FlagInProgress,FlagSprint,FlagTag,FlagID
	highlight link FlagRegion NerdTreeDir
	" Task Block
	syntax match TaskBlock "\v\s*-\s\[.{1}\]\s\zs.*\ze\s--\s.*\$\d+" contains=ExclamationMark,Info,Appointment
	highlight link TaskBlock Orange
	" Task Waiting
	syntax match TaskWaiting "\v\s*-\s\[.{1}\]\s\zs.*\ze\s--\s.*\~\d+" contains=ExclamationMark,Info,Appointment
	highlight link TaskWaiting String
	" Task Done
	syntax region TaskDone start="\v- \[x\]+" skip="\v^\t{1,}" end="^" contains=FlagID
	" Task Failed	
	syntax match TaskFailedMarker "\v\[F\]" contained
	highlight link TaskFailedMarker Error
	syntax region TaskFailed start="\v- \[F\]+" skip="\v^\t{1,}" end="^" contains=TaskFailedMarker,FlagID
	" Task Cancelled
	syntax match TaskCancelledMarker "\v\[-\]" contained
	syntax region TaskCancelled start="\v- \[-\]+" skip="\v^\t{1,}" end="^" contains=TaskCancelledMarker,FlagID
	" ... 
	highlight link TaskDone NerdTreeDir
	highlight link TaskFailed NerdTreeDir
	highlight link TaskCancelled NerdTreeDir

endfunction
command! -nargs=0 VdoSetQfSyntax	:call s:SetQfSyntax()

function! s:FilterQuickfix()

	function! Todo(idx, val)
		if a:val["text"] !~# '\v\- \[ \]'
			return v:false
		else
			return v:true
		endif
	endfunction
	
	function! Done(idx, val)
		if a:val["text"] !~# '\v\- \[x\]'
			return v:false
		else
			return v:true
		endif
	endfunction
	
	function! Failed(idx, val)
		if a:val["text"] !~# '\v\- \[F\]'
			return v:false
		else
			return v:true
		endif
	endfunction
	
	function! Cancelled(idx, val)
		if a:val["text"] !~# '\v\- \[-\]'
			return v:false
		else
			return v:true
		endif
	endfunction

	function! HasSameID(e1, e2)
		let [t1, t2] = [s:ExtractIdFull(a:e1.text), s:ExtractIdFull(a:e2.text)]
		return t1 ==# t2 ? 0 : 1
	endfunction

	function! Today(idx, val)
		let date  = s:GetDateOnly(a:val.text)
		let today = strftime("%Y-%m-%d")
		if date ==# today
			return v:true
		else
			return v:false
		endif
	endfunction

	function! Tomorrow(idx, val)
		let date     = s:GetDateOnly(a:val.text)
		let today    = strftime("%Y-%m-%d")
		let tomorrow = trim(system('dateadd '.shellescape(today).' +1d'))
		if date ==# tomorrow
			return v:true
		else
			return v:false
		endif
	endfunction

	function! ThisWeek(idx, val)
		let date   = s:GetDateOnly(a:val.text)
		let today  = strftime("%Y-%m-%d")
		let monday = trim(system('dround '.shellescape(today).' -- -Mon'))
		let sunday = trim(system('dround '.shellescape(today).' -- Sun'))
		if date >=# monday && date <=# sunday
			return v:true
		else
			return v:false
		endif
	endfunction

	function! NextWeek(idx, val)
		let date           = s:GetDateOnly(a:val.text)
		let today          = strftime("%Y-%m-%d")
		let todayinoneweek = trim(system('dateadd '.shellescape(today).' +7d'))
		let nextmonday     = trim(system('dround '.shellescape(todayinoneweek).' -- -Mon'))
		let nextsunday     = trim(system('dround '.shellescape(todayinoneweek).' -- Sun'))
		if date >=# nextmonday && date <=# nextsunday
			return v:true
		else
			return v:false
		endif
	endfunction
	
	function! ThisMonth(idx, val)
		let date             = s:GetDateOnly(a:val.text)
		let today            = strftime("%Y-%m-%d")
		let firstofmonth     = trim(system('dround '.shellescape(today).' /-1mo'))
		let firstofnextmonth = trim(system('dround '.shellescape(today).' /1mo'))
		if date >=# firstofmonth && date <# firstofnextmonth
			return v:true
		else
			return v:false
		endif
	endfunction
	
	function! Upcoming(idx, val)
		let date = s:GetDateAndTime(a:val.text)
		let now = strftime('%Y-%m-%d')
		if date <# now
			return v:false
		else
			return v:true
		endif
	endfunction
	
	function! Past(idx, val)
		let upcoming = Upcoming(a:idx, a:val)
		if upcoming == v:true
			return v:false
		else
			return v:true
		endif
	endfunction

	" get qf list
	let l:qf = getqflist()
	
	" abort if no entries
	if len(l:qf) == 0
		echoe "Empty Quickfix List."
		return
	endif
	
	let selections = [
				\ 'todo',
				\ 'done',
				\ 'failed',
				\ 'cancelled',
				\ 'unique',
				\ 'today*',
				\ 'tomorrow*',
				\ 'this week*',
				\ 'next week*',
				\ 'this month*',
				\ 'upcoming*',
				\ 'past*',
				\ 'nicen',
				\ 'syntax',
				\ ]
	let selections_dialog = [
				\ '&todo',
				\ '&done',
				\ '&failed',
				\ '&cancelled',
				\ '&unique',
				\ 't&oday*',
				\ 'to&morrow*',
				\ 't&his week*',
				\ 'n&ext week*',
				\ 'th&is month*',
				\ 'u&pcoming*',
				\ 'p&ast*',
				\ '&nicen',
				\ 'synta&x',
				\ ]
	let input  = confirm('Filter Quickfix List by', join(selections_dialog, "\n"))

	if selections[input-1] ==# 'todo'
		call filter(l:qf, function('Todo'))
	elseif selections[input-1] ==# 'done'
		call filter(l:qf, function('Done'))
	elseif selections[input-1] ==# 'failed'
		call filter(l:qf, function('Failed'))
	elseif selections[input-1] ==# 'cancelled'
		call filter(l:qf, function('Cancelled'))
	elseif selections[input-1] ==# 'unique'
		call sort(l:qf, function('s:CmpQfById'))
		call uniq(l:qf, function('HasSameID'))
		if g:vimdoit_quickfix_type ==# 'appointment'
			call sort(l:qf, function('s:CmpQfByDate'))
		else
			call sort(l:qf)
		endif
	elseif selections[input-1] ==# 'today*'
		if g:vimdoit_quickfix_type ==# 'appointment'
			call filter(l:qf, function('Today'))
		else
			echoe "Quickfix List is not of type appointment."
			return
		endif
	elseif selections[input-1] ==# 'tomorrow*'
		if g:vimdoit_quickfix_type ==# 'appointment'
			call filter(l:qf, function('Tomorrow'))
		else
			echoe "Quickfix List is not of type appointment."
			return
		endif
	elseif selections[input-1] ==# 'this week*'
		if g:vimdoit_quickfix_type ==# 'appointment'
			call filter(l:qf, function('ThisWeek'))
		else
			echoe "Quickfix List is not of type appointment."
			return
		endif
	elseif selections[input-1] ==# 'next week*'
		if g:vimdoit_quickfix_type ==# 'appointment'
			call filter(l:qf, function('NextWeek'))
		else
			echoe "Quickfix List is not of type appointment."
			return
		endif
	elseif selections[input-1] ==# 'this month*'
		if g:vimdoit_quickfix_type ==# 'appointment'
			call filter(l:qf, function('ThisMonth'))
		else
			echoe "Quickfix List is not of type appointment."
			return
		endif
	elseif selections[input-1] ==# 'upcoming*'
		if g:vimdoit_quickfix_type ==# 'appointment'
			call filter(l:qf, function('Upcoming'))
		else
			echoe "Quickfix List is not of type appointment."
			return
		endif
	elseif selections[input-1] ==# 'past*'
		if g:vimdoit_quickfix_type ==# 'appointment'
			call filter(l:qf, function('Past'))
		else
			echoe "Quickfix List is not of type appointment."
			return
		endif
	elseif selections[input-1] ==# 'nicen'
		if g:vimdoit_quickfix_type ==# 'appointment'
			call s:NicenQfByDate(l:qf)
		else
			echoe "Quickfix List is not of type appointment."
			return
		endif
	elseif selections[input-1] ==# 'syntax'
		if g:vimdoit_quickfix_type ==# 'appointment'
			call s:SetQfSyntax()
		else
			echoe "Quickfix List is not of type appointment."
			return
		endif
	endif
	
	" push list
	call setqflist(l:qf)
	call s:SetQfSyntax()
	
endfunction

function! s:JumpToToday()

	if g:vimdoit_quickfix_type !=# 'appointment'
		echoe "Quickfix List is not of type appointment."
		return
	endif
	
	" jump to today
	let today = strftime('%Y-%m-%d')
	while search('\v'.today) == 0 
		let today = trim(system('dateadd '.shellescape(today).' +1d'))
	endwhile

	execute "normal! 0"
		
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                           Modyifing Tasks                             "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:ModifyTaskStatus(state, lines)

	if a:state ==# 'done'
		let str = 'x'
	elseif a:state ==# 'todo'
		let str = ' '
	elseif a:state ==# 'failed'
		let str = 'F'
	elseif a:state ==# 'cancelled'
		let str = '-'
	endif

	for i in a:lines
		execute i.'substitute/\v^\s*- \[\zs.\ze\]/'.str.'/'
	endfor
	
endfunction

function! s:ModifyTaskBlock(lines)
	for i in a:lines
		let line = getline(i)
		" check if line is already a block?
		if line =~# '\v--.*\zs \$block\ze'
			" yes: remove block
			execute i.'substitute/\v--.*\zs \$block\ze//'
		else
			" no: add block
			call setline(i, line.' $block')
		endif		
	endfor
endfunction

function! s:PrependSelectionWithNumbers(selection)
	let new = []
	let num = 1
	for i in a:selection
		call add(new, num.' '.i)	
		let num = num + 1
	endfor
	return new
endfunction

function! s:ModifyTaskWaitingRemove(lines)
	for i in a:lines
		let blocks = s:ExtractWaitings(getline(i))
		let blocks_selection = s:PrependSelectionWithNumbers(blocks)
		let blocks_selection = extend(blocks_selection, ['all'], 0)
		let input = confirm('Select ID(s) for "'.getline(i).'": ', join(blocks_selection, "\n"))

		if blocks_selection[input-1] ==# 'all'
			" remove all
			execute i.'substitute/\v \~\x{8}//g'
		else
			" remove specific
			execute i.'substitute/\v \~'.blocks[input-2].'//'
		endif
	endfor
endfunction

function! s:ModifyTaskWaitingAdd(lines)
	for i in a:lines
		call setline(i, getline(i).' ~'.@+)
	endfor
endfunction

function! s:ModifyTaskToTask(lines)
	for i in a:lines
		execute i.'substitute/\v^\s*\zs- (\[.\])?\ze/- [ ] /'
	endfor
endfunction

function! s:ModifyTaskToNote(lines)
	for i in a:lines
		execute i.'substitute/\v^\s*\zs- (\[.\] )?\ze/- /'
	endfor
endfunction

function! s:ModifyTaskRmID(lines)
	for i in a:lines
		execute i.'substitute/\v0x\x{8}//'
	endfor
endfunction

function! s:ModifyTaskPrompt(type)
	let selections = [
				\ 'done',
				\ 'todo',
				\ 'failed',
				\ 'cancelled',
				\ 'block',
				\ 'rm waiting',
				\ 'add waiting',
				\ 'action',
				\ 'priority',
				\ 'to task',
				\ 'to note',
				\ 'rm ID',
				\ ]
	let selections_dialog = [
				\ '&done',
				\ '&todo',
				\ '&failed',
				\ '&cancelled',
				\ '&block',
				\ 'r&m waiting',
				\ 'add &waiting',
				\ '&action',
				\ '&priority',
				\ 'to ta&sk',
				\ 'to n&ote',
				\ '&rm ID',
				\ ]
	let input = confirm('Modify Task(s): ', join(selections_dialog, "\n"))

	if a:type ==# 'V'
		let start = line("'<")
		let end   = line("'>")
		let lines = range(start, end)
	elseif a:type ==# 'char'
		let lines = [ line(".") ]
	endif
	
	if selections[input-1] ==# 'done'
		call s:ModifyTaskStatus('done', lines)
	elseif selections[input-1] ==# 'todo'
		call s:ModifyTaskStatus('todo', lines)
	elseif selections[input-1] ==# 'failed'
		call s:ModifyTaskStatus('failed', lines)
	elseif selections[input-1] ==# 'cancelled'
		call s:ModifyTaskStatus('cancelled', lines)
	elseif selections[input-1] ==# 'block'
		call s:ModifyTaskBlock(lines)
	elseif selections[input-1] ==# 'rm waiting'
		call s:ModifyTaskWaitingRemove(lines)
	elseif selections[input-1] ==# 'add waiting'
		call s:ModifyTaskWaitingAdd(lines)
	elseif selections[input-1] ==# 'to task'
		call s:ModifyTaskToTask(lines)
	elseif selections[input-1] ==# 'to note'
		call s:ModifyTaskToNote(lines)
	elseif selections[input-1] ==# 'action'
		echoe "Not implemented"
	elseif selections[input-1] ==# 'priority'
		echoe "Not implemented"
	elseif selections[input-1] ==# 'rm ID'
		call s:ModifyTaskRmID(lines)
	endif
endfunction

function! s:YankTaskPrompt()
	let selections = [
				\ 'id',
				\ ]
	let selections_dialog = [
				\ '&id',
				\ ]
	let input = confirm('Yank Task Properties: ', join(selections_dialog, "\n"))
	if selections[input-1] ==# 'id'
		let @+ = s:ExtractIdFull(getline('.'))
		silent echom "ID yanked to \" register."
	endif
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                               Date File                               "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

function! s:IsInList(needle, haystack)
	for i in a:haystack
		if a:needle ==# i.date
			return v:true
		endif
	endfor
	return v:false
endfunction

function! s:IsInQfList(needle, haystack)
	for i in a:haystack
		let date = s:ExtractDate(i.text)
		if a:needle ==# date
			return v:true
		endif
	endfor
	return v:false
endfunction

function! s:GetDatefileName()
	let filepath = expand('%:h')
	let filename = expand('%:t:r')
	return filepath.'/.'.filename.'-dates.vdo'	
endfunction

function! s:WriteToDateFile(dates, id)
	" save buffer
	let l:save_buffer = bufnr()
	" save cursor
	let l:save_cursor = getcurpos()
	" save cfstack
	call vimdoit_utility#SaveCfStack()
	call s:SetGrep()

	" compute datefile name and path
	let datefile = s:GetDatefileName()

	" check if datefile exists, if not create it
	if exists(datefile) == v:false
		call system('touch '.datefile)
	endif

	" 1. grep all existing dates in datefile with same id
	execute 'silent! grep! "'.a:id.'" '.datefile

	" 2. delete existing dates, if they are not within range 
	"		 (date of task might have been changed)
	let qf        = getqflist()
	let to_delete = []

	execute 'edit! '.datefile

	" 2.1 check which dates to delete
	for i in qf
		" let str = escape(i.text, '~&$.*()|\{}[]<>')
		let d = s:ExtractDate(i.text)
		if s:IsInList(d, a:dates) == v:false
			call add(to_delete, s:ExtractIdFull(getline(i.lnum)))
		endif
	endfor

	if len(to_delete) > 0
		" 2.2 deletion
		for i in to_delete
			let id = substitute(i, '\v\|', '\\|', '')
			execute 'global/\v0x'.id.'/delete'
		endfor
		execute 'write!'
	endif
	
	"	3. insert dates, which are not already present in any project
	" 3.1 grep in all files
	execute 'silent! grep! --type-add '"vimdoit:*.vdo"' -t vimdoit "'.a:id.'\\|\d+"'
	let to_insert = []
	let qf        = getqflist()

	" 3.2 check which dates to insert
	if len(qf) == 0
		let to_insert = a:dates
		let id_new = 0
	else
		for i in a:dates
			if s:IsInQfList(i.date, qf) == v:false
				call add(to_insert, i)
			endif
		endfor
		
		" find highest date-id in use
		function! CmpQfByDateId(e1, e2)
			let [t1, t2] = [s:ExtractDateId(a:e1.text) + 0, s:ExtractDateId(a:e2.text) + 0]
			return t1 < t2 ? 1 : t1 == t2 ? 0 : -1
		endfunction
		call sort(qf, 'CmpQfByDateId')
		let id_new = s:ExtractDateId(qf[0].text) + 1
	endif

	if len(to_insert) > 0
		" open
		execute "edit ".datefile

		" append
		for i in to_insert
			let text = substitute(i.text, '\v0x\x{8}', '0x'.a:id.'|'.id_new, '')
			call append(line('$'), text)
			let id_new = id_new + 1
		endfor

		" write
		execute 'write'
		
		" TODO maybe close buffer?
	endif

	" restore cfstack
	call vimdoit_utility#RestoreCfStack()
	" restore buffer
	execute "buffer ".l:save_buffer
	" restore cursor
	call setpos('.', l:save_cursor)
	call s:RestoreGrep()

endfunction

function s:RemoveUnusedDatesDateFile()

	" abort when this is a datefile
	let basename = expand('%:t:r')
	if basename =~# '\v\..*-date'
		return
	endif
	
	" save cursor
	let l:save_cursor = getcurpos()
	
	let datefile = s:GetDatefileName()

	" abort when there is no datefile
	if filereadable(datefile) == v:false
		return
	endif

	call vimdoit_utility#SaveCfStack()
	call s:SetGrep()

	" get unique list of ids in use
	execute 'silent! grep! "0x[0-9a-f]{8}" '.datefile.' '
	let qf = getqflist()

	" empty qf list, abort
	if len(qf) == 0
		call setpos('.', l:save_cursor)
		call vimdoit_utility#RestoreCfStack()
		call s:RestoreGrep()
		return
	endif
	
	" extract ids
	let ids = []
	for i in qf
		call add(ids, s:ExtractId(i.text))	
	endfor
	
	" make unique
	call uniq(sort(ids))

	" check if those ids still exist
	let rm = []
	for i in ids
		let pattern = '0x'.i
		execute 'silent! grep! --type-add '"vimdoit:*.vdo"' -t vimdoit -g "!.*" "'.pattern.'"'
		let qf = getqflist()
		if len(qf) == 0
			call add(rm, i)
		endif
	endfor

	" actual removal
	execute 'edit! '.datefile
	for i in rm
		execute 'silent! global/\v0x'.i.'/delete'
	endfor
	execute 'write!'
	
	" restore
	call setpos('.', l:save_cursor)
	call vimdoit_utility#RestoreCfStack()
	call s:RestoreGrep()
endfunction

function! s:UpdateDatesDatesFile()
	let save_cursor = getcurpos()
	let save_file = expand('%')
	execute 'args ./**/*\.vdo'
	execute 'bufdo write!'
	execute '%bdelete!'
	execute 'edit '.save_file
	call setpos('.', save_cursor)
endfunction
command! -nargs=0 VdoUpdateDates	:call s:UpdateDatesDatesFile()

function! s:SortDateFile()
	let save_cursor = getcurpos()
	let save_file = expand('%')
	let datefile = s:GetDatefileName()
	execute 'edit! '.datefile
	execute '%sort'
	execute 'write!'
	let buf = bufnr()
	execute 'edit '.save_file
	call setpos('.', save_cursor)
	execute buf.'bdelete!'
endfunction

function! s:UpdateFirstLineOfDateFile()
	if has_key(s:project_tree['flags'], 'tag') == v:false
		return
	endif
	let save_cursor = getcurpos()
	let save_file = expand('%')
	let datefile = s:GetDatefileName()
	execute 'edit! '.datefile
	call setline('1', join(s:project_tree['flags']['tag'], " "))
	execute 'write!'
	let buf = bufnr()
	execute 'edit '.save_file
	call setpos('.', save_cursor)
	execute buf.'bdelete!'
endfunction
	
function! s:UpdateDateFile()
	
	" skip when this is a datefile
	let basename = expand('%:t:r')
	if basename =~# '\v\..*-date'
		return
	endif

	" get all tasks/notes
	let l:tasks = { 'items' : [] }
	call s:DataGetAllTasksAndNotes(s:project_tree, l:tasks)
	
	" decide what to do
	for item in l:tasks['items']

		" abort if task/note has invalid syntax
		if item.valid_syntax == v:false
			continue
		endif

		" check if task has a repetition
		if s:HasRepetition(item.name) == v:true
			let dates = []
			" extract start date
			let start = s:ExtractStartDateOfRepetition(item.name)
			" extract end date
			let end = s:ExtractEndDateOfRepetition(item.name)
			" extract time
			let time = s:ExtractTimeOfRepetition(item.name)
			" extract repetition operator
			let operator = s:ExtractRepetitionOperator(item.name)
			" extract repetition operand
			let operand = s:ExtractRepetitionOperand(item.name)

			" echom "line:".item.name
			" echom "start:".start
			" echom "end:".end
			" echom "time:".time
			" echom "operator:".operator
			" echom "operand:".operand
			" echom "--"
			
			" Add repetitions into the future, but limit how many.
			" We don't want do flood the datefiles with too much data, otherwise
			" grepping will be slowed down.
			if end ==# '2999-12-31'
				let today = strftime('%Y-%m-%d')

				if operator ==# 'd'
					let limit = trim(system('dateadd '.shellescape(today).' +3mo'))
				elseif operator ==# 'w'
					let limit = trim(system('dateadd '.shellescape(today).' +6mo'))
				elseif operator ==# 'mo'
					let limit = trim(system('dateadd '.shellescape(today).' +2y'))
				elseif operator ==# 'y'
					let limit = trim(system('dateadd '.shellescape(today).' +30y'))
				else
					let limit = trim(system('dateadd '.shellescape(today).' +3mo'))
				endif
				
			else
				let limit = end
			endif
				
			let cur   = start
			while cur <=# limit && cur <=# end
				let text = substitute(item.name, '\v\{.*\|[a-z]{1,2}:.*(\|.*)?\}', '{'.cur.time.'}', '')
				if item.type ==# 'task'
					let text = '- [ ] '.text
				elseif item.type ==# 'note'
					let text = '- '.text
				endif
				call add(dates, { 'text' : text, 'date' : cur })
				" date addition
				let cur = trim(system('dateadd '.shellescape(cur).' +'.operand.operator))	
			endwhile
			" write interpolated dates to datefile
			call s:WriteToDateFile(dates, item.id)
			call s:SortDateFile()
			call s:UpdateFirstLineOfDateFile()
		endif
		
	endfor

endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                               Mappings                                "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if exists("g:vimdoit_did_load_mappings") == v:false
		" Grep projects in cwd
		nnoremap <leader>p	:<c-u>call <SID>GrepProjects(v:false)<cr>
		" Grep projects in root
		nnoremap <leader>P	:<c-u>call <SID>GrepProjects(v:true)<cr>
		" Grep tasks in project
		nnoremap <leader>tt	:<c-u>call <SID>GrepTasks("project")<cr>
		" Grep tasks in cwd
		nnoremap <leader>t.	:<c-u>call <SID>GrepTasks("area")<cr>
		" Grep tasks in root
		nnoremap <leader>t/	:<c-u>call <SID>GrepTasks("all")<cr>
		" Sort quickfix list
		nnoremap <leader>qs	:<c-u>call <SID>SortQuickfix()<cr>
		" Filter quickfix list
		nnoremap <leader>qf	:<c-u>call <SID>FilterQuickfix()<cr>
		" Modify Task Prompt (Normal)
		nnoremap M	:<c-u>call <SID>ModifyTaskPrompt('char')<cr>
		" Modify Task Prompt (Visual)
		vnoremap M	:<c-u>call <SID>ModifyTaskPrompt(visualmode())<cr>
		" Jump in Quickfix List to Today
		nnoremap <leader>qj	:<c-u>call <SID>JumpToToday()<cr>
		" Yank Task Prompt (Normal)
		nnoremap Y	:<c-u>call <SID>YankTaskPrompt()<cr>

		let g:vimdoit_did_load_mappings = 1
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                             Autocommands                              "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup VimDoit
	autocmd!
	" disable .swap files, otherwise changing tasks/notes in external files won't work
	autocmd BufEnter *.vdo setlocal noswapfile
	autocmd BufWritePre *.vdo call s:AfterProjectChange()
	autocmd BufWritePost *.vdo call s:UpdateDateFile()
	autocmd BufWritePost *.vdo call s:RemoveUnusedDatesDateFile()
augroup END



" Restore user's options.
let &cpo = s:save_cpo
unlet s:save_cpo
